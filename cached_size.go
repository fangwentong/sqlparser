/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by Sizegen. DO NOT EDIT.

package sqlparser

import (
	"github.com/xwb1989/sqlparser/internal/dependency/hack"
)

type cachedObject interface {
	CachedSize(alloc bool) int64
}

func (cached *AddColumns) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Columns []*github.com/xwb1989/sqlparser.ColumnDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field After *github.com/xwb1989/sqlparser.ColName
	size += cached.After.CachedSize(true)
	return size
}
func (cached *AddConstraintDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field ConstraintDefinition *github.com/xwb1989/sqlparser.ConstraintDefinition
	size += cached.ConstraintDefinition.CachedSize(true)
	return size
}
func (cached *AddIndexDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field IndexDefinition *github.com/xwb1989/sqlparser.IndexDefinition
	size += cached.IndexDefinition.CachedSize(true)
	return size
}
func (cached *AliasedExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field As github.com/xwb1989/sqlparser.ColIdent
	size += cached.As.CachedSize(false)
	return size
}
func (cached *AliasedTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Expr github.com/xwb1989/sqlparser.SimpleTableExpr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Partitions github.com/xwb1989/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Partitions)) * int64(40))
		for _, elem := range cached.Partitions {
			size += elem.CachedSize(false)
		}
	}
	// field As github.com/xwb1989/sqlparser.TableIdent
	size += cached.As.CachedSize(false)
	// field Hints *github.com/xwb1989/sqlparser.IndexHints
	size += cached.Hints.CachedSize(true)
	// field Columns github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(40))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *AlterCharset) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field CharacterSet string
	size += hack.RuntimeAllocSize(int64(len(cached.CharacterSet)))
	// field Collate string
	size += hack.RuntimeAllocSize(int64(len(cached.Collate)))
	return size
}
func (cached *AlterColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Column *github.com/xwb1989/sqlparser.ColName
	size += cached.Column.CachedSize(true)
	// field DefaultVal github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.DefaultVal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *AlterDatabase) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field DBName github.com/xwb1989/sqlparser.TableIdent
	size += cached.DBName.CachedSize(false)
	// field AlterOptions []github.com/xwb1989/sqlparser.CollateAndCharset
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.AlterOptions)) * int64(24))
		for _, elem := range cached.AlterOptions {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *AlterMigration) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field UUID string
	size += hack.RuntimeAllocSize(int64(len(cached.UUID)))
	return size
}
func (cached *AlterTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field AlterOptions []github.com/xwb1989/sqlparser.AlterOption
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.AlterOptions)) * int64(16))
		for _, elem := range cached.AlterOptions {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field PartitionSpec *github.com/xwb1989/sqlparser.PartitionSpec
	size += cached.PartitionSpec.CachedSize(true)
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *AlterView) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(144)
	}
	// field ViewName github.com/xwb1989/sqlparser.TableName
	size += cached.ViewName.CachedSize(false)
	// field Algorithm string
	size += hack.RuntimeAllocSize(int64(len(cached.Algorithm)))
	// field Definer string
	size += hack.RuntimeAllocSize(int64(len(cached.Definer)))
	// field Security string
	size += hack.RuntimeAllocSize(int64(len(cached.Security)))
	// field Columns github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(40))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Select github.com/xwb1989/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field CheckOption string
	size += hack.RuntimeAllocSize(int64(len(cached.CheckOption)))
	return size
}
func (cached *AlterVschema) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field VindexSpec *github.com/xwb1989/sqlparser.VindexSpec
	size += cached.VindexSpec.CachedSize(true)
	// field VindexCols []github.com/xwb1989/sqlparser.ColIdent
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.VindexCols)) * int64(40))
		for _, elem := range cached.VindexCols {
			size += elem.CachedSize(false)
		}
	}
	// field AutoIncSpec *github.com/xwb1989/sqlparser.AutoIncSpec
	size += cached.AutoIncSpec.CachedSize(true)
	return size
}
func (cached *AndExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *AutoIncSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Column github.com/xwb1989/sqlparser.ColIdent
	size += cached.Column.CachedSize(false)
	// field Sequence github.com/xwb1989/sqlparser.TableName
	size += cached.Sequence.CachedSize(false)
	return size
}
func (cached *BetweenExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field From github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.From.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field To github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.To.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BinaryExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BindVarNeeds) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field NeedFunctionResult []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.NeedFunctionResult)) * int64(16))
		for _, elem := range cached.NeedFunctionResult {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field NeedSystemVariable []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.NeedSystemVariable)) * int64(16))
		for _, elem := range cached.NeedSystemVariable {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field NeedUserDefinedVariables []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.NeedUserDefinedVariables)) * int64(16))
		for _, elem := range cached.NeedUserDefinedVariables {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *CallProc) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xwb1989/sqlparser.TableName
	size += cached.Name.CachedSize(false)
	// field Params github.com/xwb1989/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(16))
		for _, elem := range cached.Params {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *CaseExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Whens []*github.com/xwb1989/sqlparser.When
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Whens)) * int64(8))
		for _, elem := range cached.Whens {
			size += elem.CachedSize(true)
		}
	}
	// field Else github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Else.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ChangeColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field OldColumn *github.com/xwb1989/sqlparser.ColName
	size += cached.OldColumn.CachedSize(true)
	// field NewColDefinition *github.com/xwb1989/sqlparser.ColumnDefinition
	size += cached.NewColDefinition.CachedSize(true)
	// field After *github.com/xwb1989/sqlparser.ColName
	size += cached.After.CachedSize(true)
	return size
}
func (cached *CheckConstraintDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ColIdent) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field val string
	size += hack.RuntimeAllocSize(int64(len(cached.val)))
	// field lowered string
	size += hack.RuntimeAllocSize(int64(len(cached.lowered)))
	return size
}
func (cached *ColName) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Qualifier github.com/xwb1989/sqlparser.TableName
	size += cached.Qualifier.CachedSize(false)
	return size
}
func (cached *CollateAndCharset) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Value string
	size += hack.RuntimeAllocSize(int64(len(cached.Value)))
	return size
}
func (cached *CollateExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Collation string
	size += hack.RuntimeAllocSize(int64(len(cached.Collation)))
	return size
}
func (cached *ColumnDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(128)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Type github.com/xwb1989/sqlparser.ColumnType
	size += cached.Type.CachedSize(false)
	return size
}
func (cached *ColumnType) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field Options *github.com/xwb1989/sqlparser.ColumnTypeOptions
	size += cached.Options.CachedSize(true)
	// field Length *github.com/xwb1989/sqlparser.Literal
	size += cached.Length.CachedSize(true)
	// field Scale *github.com/xwb1989/sqlparser.Literal
	size += cached.Scale.CachedSize(true)
	// field Charset string
	size += hack.RuntimeAllocSize(int64(len(cached.Charset)))
	// field EnumValues []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.EnumValues)) * int64(16))
		for _, elem := range cached.EnumValues {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *ColumnTypeOptions) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Null *bool
	size += hack.RuntimeAllocSize(int64(1))
	// field Default github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Default.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OnUpdate github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.OnUpdate.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field As github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.As.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Comment *github.com/xwb1989/sqlparser.Literal
	size += cached.Comment.CachedSize(true)
	// field Collate string
	size += hack.RuntimeAllocSize(int64(len(cached.Collate)))
	// field Reference *github.com/xwb1989/sqlparser.ReferenceDefinition
	size += cached.Reference.CachedSize(true)
	return size
}
func (cached *CommonTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field TableID github.com/xwb1989/sqlparser.TableIdent
	size += cached.TableID.CachedSize(false)
	// field Columns github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(40))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Subquery *github.com/xwb1989/sqlparser.Subquery
	size += cached.Subquery.CachedSize(true)
	return size
}
func (cached *ComparisonExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Escape github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Escape.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ConstraintDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Details github.com/xwb1989/sqlparser.ConstraintInfo
	if cc, ok := cached.Details.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ConvertExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Type *github.com/xwb1989/sqlparser.ConvertType
	size += cached.Type.CachedSize(true)
	return size
}
func (cached *ConvertType) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field Length *github.com/xwb1989/sqlparser.Literal
	size += cached.Length.CachedSize(true)
	// field Scale *github.com/xwb1989/sqlparser.Literal
	size += cached.Scale.CachedSize(true)
	// field Charset string
	size += hack.RuntimeAllocSize(int64(len(cached.Charset)))
	return size
}
func (cached *ConvertUsingExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	return size
}
func (cached *CreateDatabase) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field DBName github.com/xwb1989/sqlparser.TableIdent
	size += cached.DBName.CachedSize(false)
	// field CreateOptions []github.com/xwb1989/sqlparser.CollateAndCharset
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.CreateOptions)) * int64(24))
		for _, elem := range cached.CreateOptions {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *CreateTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field TableSpec *github.com/xwb1989/sqlparser.TableSpec
	size += cached.TableSpec.CachedSize(true)
	// field OptLike *github.com/xwb1989/sqlparser.OptLike
	size += cached.OptLike.CachedSize(true)
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *CreateView) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(144)
	}
	// field ViewName github.com/xwb1989/sqlparser.TableName
	size += cached.ViewName.CachedSize(false)
	// field Algorithm string
	size += hack.RuntimeAllocSize(int64(len(cached.Algorithm)))
	// field Definer string
	size += hack.RuntimeAllocSize(int64(len(cached.Definer)))
	// field Security string
	size += hack.RuntimeAllocSize(int64(len(cached.Security)))
	// field Columns github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(40))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Select github.com/xwb1989/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field CheckOption string
	size += hack.RuntimeAllocSize(int64(len(cached.CheckOption)))
	return size
}
func (cached *CurTimeFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Fsp github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Fsp.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Default) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field ColName string
	size += hack.RuntimeAllocSize(int64(len(cached.ColName)))
	return size
}
func (cached *Delete) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(160)
	}
	// field With *github.com/xwb1989/sqlparser.With
	size += cached.With.CachedSize(true)
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field Targets github.com/xwb1989/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Targets)) * int64(32))
		for _, elem := range cached.Targets {
			size += elem.CachedSize(false)
		}
	}
	// field TableExprs github.com/xwb1989/sqlparser.TableExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TableExprs)) * int64(16))
		for _, elem := range cached.TableExprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Partitions github.com/xwb1989/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Partitions)) * int64(40))
		for _, elem := range cached.Partitions {
			size += elem.CachedSize(false)
		}
	}
	// field Where *github.com/xwb1989/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field OrderBy github.com/xwb1989/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Limit *github.com/xwb1989/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *DerivedTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Select github.com/xwb1989/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *DropColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field Name *github.com/xwb1989/sqlparser.ColName
	size += cached.Name.CachedSize(true)
	return size
}
func (cached *DropDatabase) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field DBName github.com/xwb1989/sqlparser.TableIdent
	size += cached.DBName.CachedSize(false)
	return size
}
func (cached *DropKey) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *DropTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field FromTables github.com/xwb1989/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.FromTables)) * int64(32))
		for _, elem := range cached.FromTables {
			size += elem.CachedSize(false)
		}
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *DropView) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field FromTables github.com/xwb1989/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.FromTables)) * int64(32))
		for _, elem := range cached.FromTables {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *ExistsExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field Subquery *github.com/xwb1989/sqlparser.Subquery
	size += cached.Subquery.CachedSize(true)
	return size
}
func (cached *ExplainStmt) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Statement github.com/xwb1989/sqlparser.Statement
	if cc, ok := cached.Statement.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ExplainTab) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field Wild string
	size += hack.RuntimeAllocSize(int64(len(cached.Wild)))
	return size
}
func (cached *ExprOrColumns) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field ColumnList github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ColumnList)) * int64(40))
		for _, elem := range cached.ColumnList {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *ExtractFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ExtractedSubquery) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Original github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Original.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Subquery *github.com/xwb1989/sqlparser.Subquery
	size += cached.Subquery.CachedSize(true)
	// field OtherSide github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.OtherSide.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field hasValuesArg string
	size += hack.RuntimeAllocSize(int64(len(cached.hasValuesArg)))
	// field argName string
	size += hack.RuntimeAllocSize(int64(len(cached.argName)))
	// field alternative github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.alternative.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Flush) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field FlushOptions []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.FlushOptions)) * int64(16))
		for _, elem := range cached.FlushOptions {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field TableNames github.com/xwb1989/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TableNames)) * int64(32))
		for _, elem := range cached.TableNames {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *ForeignKeyDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Source github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Source)) * int64(40))
		for _, elem := range cached.Source {
			size += elem.CachedSize(false)
		}
	}
	// field IndexName github.com/xwb1989/sqlparser.ColIdent
	size += cached.IndexName.CachedSize(false)
	// field ReferenceDefinition *github.com/xwb1989/sqlparser.ReferenceDefinition
	size += cached.ReferenceDefinition.CachedSize(true)
	return size
}
func (cached *FuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Qualifier github.com/xwb1989/sqlparser.TableIdent
	size += cached.Qualifier.CachedSize(false)
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Exprs github.com/xwb1989/sqlparser.SelectExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *GroupConcatExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Exprs github.com/xwb1989/sqlparser.SelectExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field OrderBy github.com/xwb1989/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Separator string
	size += hack.RuntimeAllocSize(int64(len(cached.Separator)))
	// field Limit *github.com/xwb1989/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *IndexColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Column github.com/xwb1989/sqlparser.ColIdent
	size += cached.Column.CachedSize(false)
	// field Length *github.com/xwb1989/sqlparser.Literal
	size += cached.Length.CachedSize(true)
	return size
}
func (cached *IndexDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Info *github.com/xwb1989/sqlparser.IndexInfo
	size += cached.Info.CachedSize(true)
	// field Columns []*github.com/xwb1989/sqlparser.IndexColumn
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field Options []*github.com/xwb1989/sqlparser.IndexOption
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Options)) * int64(8))
		for _, elem := range cached.Options {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *IndexHints) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Indexes []github.com/xwb1989/sqlparser.ColIdent
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Indexes)) * int64(40))
		for _, elem := range cached.Indexes {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *IndexInfo) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field ConstraintName github.com/xwb1989/sqlparser.ColIdent
	size += cached.ConstraintName.CachedSize(false)
	return size
}
func (cached *IndexOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Value *github.com/xwb1989/sqlparser.Literal
	size += cached.Value.CachedSize(true)
	// field String string
	size += hack.RuntimeAllocSize(int64(len(cached.String)))
	return size
}
func (cached *Insert) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(160)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field Partitions github.com/xwb1989/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Partitions)) * int64(40))
		for _, elem := range cached.Partitions {
			size += elem.CachedSize(false)
		}
	}
	// field Columns github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(40))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Rows github.com/xwb1989/sqlparser.InsertRows
	if cc, ok := cached.Rows.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OnDup github.com/xwb1989/sqlparser.OnDup
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OnDup)) * int64(8))
		for _, elem := range cached.OnDup {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *IntervalExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Unit string
	size += hack.RuntimeAllocSize(int64(len(cached.Unit)))
	return size
}
func (cached *IntroducerExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field CharacterSet string
	size += hack.RuntimeAllocSize(int64(len(cached.CharacterSet)))
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *IsExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JoinCondition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field On github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.On.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Using github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Using)) * int64(40))
		for _, elem := range cached.Using {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *JoinTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field LeftExpr github.com/xwb1989/sqlparser.TableExpr
	if cc, ok := cached.LeftExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field RightExpr github.com/xwb1989/sqlparser.TableExpr
	if cc, ok := cached.RightExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Condition *github.com/xwb1989/sqlparser.JoinCondition
	size += cached.Condition.CachedSize(true)
	return size
}
func (cached *KeyState) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *Limit) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Offset github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Offset.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Rowcount github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Rowcount.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Literal) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Val string
	size += hack.RuntimeAllocSize(int64(len(cached.Val)))
	return size
}
func (cached *LockOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *LockTables) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Tables github.com/xwb1989/sqlparser.TableAndLockTypes
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Tables)) * int64(8))
		for _, elem := range cached.Tables {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *MatchExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Columns github.com/xwb1989/sqlparser.SelectExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(16))
		for _, elem := range cached.Columns {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ModifyColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field NewColDefinition *github.com/xwb1989/sqlparser.ColumnDefinition
	size += cached.NewColDefinition.CachedSize(true)
	// field After *github.com/xwb1989/sqlparser.ColName
	size += cached.After.CachedSize(true)
	return size
}
func (cached *Nextval) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *NotExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *OptLike) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field LikeTable github.com/xwb1989/sqlparser.TableName
	size += cached.LikeTable.CachedSize(false)
	return size
}
func (cached *OrExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Order) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *OrderByOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Cols github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Cols)) * int64(40))
		for _, elem := range cached.Cols {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *ParenTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Exprs github.com/xwb1989/sqlparser.TableExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *ParsedQuery) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Query string
	size += hack.RuntimeAllocSize(int64(len(cached.Query)))
	// field bindLocations []github.com/xwb1989/sqlparser.bindLocation
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.bindLocations)) * int64(16))
	}
	return size
}
func (cached *PartitionDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Limit github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Limit.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *PartitionOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(160)
	}
	// field Linear string
	size += hack.RuntimeAllocSize(int64(len(cached.Linear)))
	// field KeyAlgorithm string
	size += hack.RuntimeAllocSize(int64(len(cached.KeyAlgorithm)))
	// field KeyColList github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.KeyColList)) * int64(40))
		for _, elem := range cached.KeyColList {
			size += elem.CachedSize(false)
		}
	}
	// field RangeOrList string
	size += hack.RuntimeAllocSize(int64(len(cached.RangeOrList)))
	// field ExprOrCol *github.com/xwb1989/sqlparser.ExprOrColumns
	size += cached.ExprOrCol.CachedSize(true)
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Partitions string
	size += hack.RuntimeAllocSize(int64(len(cached.Partitions)))
	// field SubPartition *github.com/xwb1989/sqlparser.SubPartition
	size += cached.SubPartition.CachedSize(true)
	// field Definitions []*github.com/xwb1989/sqlparser.PartitionDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Definitions)) * int64(8))
		for _, elem := range cached.Definitions {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *PartitionSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Names github.com/xwb1989/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Names)) * int64(40))
		for _, elem := range cached.Names {
			size += elem.CachedSize(false)
		}
	}
	// field Number *github.com/xwb1989/sqlparser.Literal
	size += cached.Number.CachedSize(true)
	// field TableName github.com/xwb1989/sqlparser.TableName
	size += cached.TableName.CachedSize(false)
	// field Definitions []*github.com/xwb1989/sqlparser.PartitionDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Definitions)) * int64(8))
		for _, elem := range cached.Definitions {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *ReferenceDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field ReferencedTable github.com/xwb1989/sqlparser.TableName
	size += cached.ReferencedTable.CachedSize(false)
	// field ReferencedColumns github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ReferencedColumns)) * int64(40))
		for _, elem := range cached.ReferencedColumns {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *Release) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *RenameIndex) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field OldName github.com/xwb1989/sqlparser.ColIdent
	size += cached.OldName.CachedSize(false)
	// field NewName github.com/xwb1989/sqlparser.ColIdent
	size += cached.NewName.CachedSize(false)
	return size
}
func (cached *RenameTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field TablePairs []*github.com/xwb1989/sqlparser.RenameTablePair
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TablePairs)) * int64(8))
		for _, elem := range cached.TablePairs {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *RenameTableName) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	return size
}
func (cached *RenameTablePair) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field FromTable github.com/xwb1989/sqlparser.TableName
	size += cached.FromTable.CachedSize(false)
	// field ToTable github.com/xwb1989/sqlparser.TableName
	size += cached.ToTable.CachedSize(false)
	return size
}
func (cached *RevertMigration) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field UUID string
	size += hack.RuntimeAllocSize(int64(len(cached.UUID)))
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *RootNode) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field SQLNode github.com/xwb1989/sqlparser.SQLNode
	if cc, ok := cached.SQLNode.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *SRollback) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *Savepoint) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *Select) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(192)
	}
	// field Cache *bool
	size += hack.RuntimeAllocSize(int64(1))
	// field From []github.com/xwb1989/sqlparser.TableExpr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.From)) * int64(16))
		for _, elem := range cached.From {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field SelectExprs github.com/xwb1989/sqlparser.SelectExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.SelectExprs)) * int64(16))
		for _, elem := range cached.SelectExprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Where *github.com/xwb1989/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field With *github.com/xwb1989/sqlparser.With
	size += cached.With.CachedSize(true)
	// field GroupBy github.com/xwb1989/sqlparser.GroupBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.GroupBy)) * int64(16))
		for _, elem := range cached.GroupBy {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Having *github.com/xwb1989/sqlparser.Where
	size += cached.Having.CachedSize(true)
	// field OrderBy github.com/xwb1989/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Limit *github.com/xwb1989/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	// field Into *github.com/xwb1989/sqlparser.SelectInto
	size += cached.Into.CachedSize(true)
	return size
}
func (cached *SelectInto) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field FileName string
	size += hack.RuntimeAllocSize(int64(len(cached.FileName)))
	// field Charset string
	size += hack.RuntimeAllocSize(int64(len(cached.Charset)))
	// field FormatOption string
	size += hack.RuntimeAllocSize(int64(len(cached.FormatOption)))
	// field ExportOption string
	size += hack.RuntimeAllocSize(int64(len(cached.ExportOption)))
	// field Manifest string
	size += hack.RuntimeAllocSize(int64(len(cached.Manifest)))
	// field Overwrite string
	size += hack.RuntimeAllocSize(int64(len(cached.Overwrite)))
	return size
}
func (cached *Set) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field Exprs github.com/xwb1989/sqlparser.SetExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(8))
		for _, elem := range cached.Exprs {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *SetExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *SetTransaction) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field SQLNode github.com/xwb1989/sqlparser.SQLNode
	if cc, ok := cached.SQLNode.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field Characteristics []github.com/xwb1989/sqlparser.Characteristic
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Characteristics)) * int64(16))
		for _, elem := range cached.Characteristics {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *Show) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Internal github.com/xwb1989/sqlparser.ShowInternal
	if cc, ok := cached.Internal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ShowBasic) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Tbl github.com/xwb1989/sqlparser.TableName
	size += cached.Tbl.CachedSize(false)
	// field DbName github.com/xwb1989/sqlparser.TableIdent
	size += cached.DbName.CachedSize(false)
	// field Filter *github.com/xwb1989/sqlparser.ShowFilter
	size += cached.Filter.CachedSize(true)
	return size
}
func (cached *ShowCreate) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Op github.com/xwb1989/sqlparser.TableName
	size += cached.Op.CachedSize(false)
	return size
}
func (cached *ShowFilter) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Like string
	size += hack.RuntimeAllocSize(int64(len(cached.Like)))
	// field Filter github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Filter.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ShowLegacy) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(128)
	}
	// field Extended string
	size += hack.RuntimeAllocSize(int64(len(cached.Extended)))
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field OnTable github.com/xwb1989/sqlparser.TableName
	size += cached.OnTable.CachedSize(false)
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field ShowTablesOpt *github.com/xwb1989/sqlparser.ShowTablesOpt
	size += cached.ShowTablesOpt.CachedSize(true)
	// field ShowCollationFilterOpt github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.ShowCollationFilterOpt.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ShowMigrationLogs) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field UUID string
	size += hack.RuntimeAllocSize(int64(len(cached.UUID)))
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *ShowTablesOpt) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Full string
	size += hack.RuntimeAllocSize(int64(len(cached.Full)))
	// field DbName string
	size += hack.RuntimeAllocSize(int64(len(cached.DbName)))
	// field Filter *github.com/xwb1989/sqlparser.ShowFilter
	size += cached.Filter.CachedSize(true)
	return size
}
func (cached *StarExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field TableName github.com/xwb1989/sqlparser.TableName
	size += cached.TableName.CachedSize(false)
	return size
}
func (cached *Stream) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field SelectExpr github.com/xwb1989/sqlparser.SelectExpr
	if cc, ok := cached.SelectExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	return size
}
func (cached *SubPartition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Linear string
	size += hack.RuntimeAllocSize(int64(len(cached.Linear)))
	// field KeyAlgorithm string
	size += hack.RuntimeAllocSize(int64(len(cached.KeyAlgorithm)))
	// field KeyColList github.com/xwb1989/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.KeyColList)) * int64(40))
		for _, elem := range cached.KeyColList {
			size += elem.CachedSize(false)
		}
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field SubPartitions string
	size += hack.RuntimeAllocSize(int64(len(cached.SubPartitions)))
	return size
}
func (cached *Subquery) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Select github.com/xwb1989/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *SubstrExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Name.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field From github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.From.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field To github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.To.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *TableAndLockType) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Table github.com/xwb1989/sqlparser.TableExpr
	if cc, ok := cached.Table.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *TableIdent) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field v string
	size += hack.RuntimeAllocSize(int64(len(cached.v)))
	return size
}
func (cached *TableName) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name github.com/xwb1989/sqlparser.TableIdent
	size += cached.Name.CachedSize(false)
	// field Qualifier github.com/xwb1989/sqlparser.TableIdent
	size += cached.Qualifier.CachedSize(false)
	return size
}
func (cached *TableOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Value *github.com/xwb1989/sqlparser.Literal
	size += cached.Value.CachedSize(true)
	// field String string
	size += hack.RuntimeAllocSize(int64(len(cached.String)))
	// field Tables github.com/xwb1989/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Tables)) * int64(32))
		for _, elem := range cached.Tables {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *TableSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Columns []*github.com/xwb1989/sqlparser.ColumnDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field Indexes []*github.com/xwb1989/sqlparser.IndexDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Indexes)) * int64(8))
		for _, elem := range cached.Indexes {
			size += elem.CachedSize(true)
		}
	}
	// field Constraints []*github.com/xwb1989/sqlparser.ConstraintDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Constraints)) * int64(8))
		for _, elem := range cached.Constraints {
			size += elem.CachedSize(true)
		}
	}
	// field Options github.com/xwb1989/sqlparser.TableOptions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Options)) * int64(8))
		for _, elem := range cached.Options {
			size += elem.CachedSize(true)
		}
	}
	// field PartitionOption *github.com/xwb1989/sqlparser.PartitionOption
	size += cached.PartitionOption.CachedSize(true)
	return size
}
func (cached *TablespaceOperation) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *TimestampFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Expr1 github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr1.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Expr2 github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr2.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Unit string
	size += hack.RuntimeAllocSize(int64(len(cached.Unit)))
	return size
}
func (cached *TruncateTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	return size
}
func (cached *UnaryExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Union) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Left github.com/xwb1989/sqlparser.SelectStatement
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xwb1989/sqlparser.SelectStatement
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OrderBy github.com/xwb1989/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field With *github.com/xwb1989/sqlparser.With
	size += cached.With.CachedSize(true)
	// field Limit *github.com/xwb1989/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	// field Into *github.com/xwb1989/sqlparser.SelectInto
	size += cached.Into.CachedSize(true)
	return size
}
func (cached *Update) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(128)
	}
	// field With *github.com/xwb1989/sqlparser.With
	size += cached.With.CachedSize(true)
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field TableExprs github.com/xwb1989/sqlparser.TableExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TableExprs)) * int64(16))
		for _, elem := range cached.TableExprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Exprs github.com/xwb1989/sqlparser.UpdateExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(8))
		for _, elem := range cached.Exprs {
			size += elem.CachedSize(true)
		}
	}
	// field Where *github.com/xwb1989/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field OrderBy github.com/xwb1989/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Limit *github.com/xwb1989/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *UpdateExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Name *github.com/xwb1989/sqlparser.ColName
	size += cached.Name.CachedSize(true)
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Use) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field DBName github.com/xwb1989/sqlparser.TableIdent
	size += cached.DBName.CachedSize(false)
	return size
}
func (cached *VStream) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Comments github.com/xwb1989/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field SelectExpr github.com/xwb1989/sqlparser.SelectExpr
	if cc, ok := cached.SelectExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Table github.com/xwb1989/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field Where *github.com/xwb1989/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field Limit *github.com/xwb1989/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *Validation) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *ValuesFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field Name *github.com/xwb1989/sqlparser.ColName
	size += cached.Name.CachedSize(true)
	return size
}
func (cached *VindexParam) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Key github.com/xwb1989/sqlparser.ColIdent
	size += cached.Key.CachedSize(false)
	// field Val string
	size += hack.RuntimeAllocSize(int64(len(cached.Val)))
	return size
}
func (cached *VindexSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Name github.com/xwb1989/sqlparser.ColIdent
	size += cached.Name.CachedSize(false)
	// field Type github.com/xwb1989/sqlparser.ColIdent
	size += cached.Type.CachedSize(false)
	// field Params []github.com/xwb1989/sqlparser.VindexParam
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(56))
		for _, elem := range cached.Params {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *When) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Cond github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Cond.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Val github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Val.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Where) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *With) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field ctes []*github.com/xwb1989/sqlparser.CommonTableExpr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ctes)) * int64(8))
		for _, elem := range cached.ctes {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *XorExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Left github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xwb1989/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
